#include "../../imports/stdlib.fc";
#include "../../imports/tsa_functions.fc";

() on_internal_message_send(int balance, int msg_value, cell in_msg_full, slice msg_body, int input_id) impure method_id {

    tsa_forbid_failures();
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    tsa_assert_not(flags & 1);

    int contract_balance = tsa_call_1_0(1, 1650);
    tsa_assert(contract_balance == 0);


    if (input_id == 0) {
        tsa_assert(msg_value > 10000000000);

        int op = msg_body~load_uint(32);
        tsa_assert(op == 100);
    }
    if (input_id == 1) {
        tsa_assert(msg_value > 10000000000);

        int op = msg_body~load_uint(32);
        tsa_assert(op == 101);
    }
    if (input_id == 2) {
        tsa_assert(msg_value == 100000000);

        int op = msg_body~load_uint(32);
        tsa_assert(op == 102);
    }
    if (input_id == 3) {
        tsa_assert(msg_value > 10000000000);
        
        int op = msg_body~load_uint(32);
        tsa_assert(op == 105);
    }

    tsa_allow_failures();
}

() main() impure {
    tsa_forbid_failures();

    slice data1 = tsa_get_c4(1).begin_parse(); ;; c4 of send_ignore_error_flag.fc
    int bounced? = data1~load_uint(1);
    tsa_assert(bounced? == 0);

    tsa_allow_failures();

    tsa_send_internal_message(1, 0); ;; We should not get an exception here

    tsa_send_internal_message(1, 1); ;; And here

    tsa_send_internal_message(1, 2); ;; And here

    tsa_send_internal_message(1, 3); ;; And, finally, here

    slice data_aft_last_msg = tsa_get_c4(1).begin_parse();
    int bounced_aft_last_msg = data_aft_last_msg~load_uint(1);

    throw_if(258, bounced_aft_last_msg == 1); ;; the contract should receive bounced message after the last message
}
