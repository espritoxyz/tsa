package org.ton.examples.continuations

import org.junit.jupiter.api.Assertions
import org.ton.examples.compareSymbolicAndConcreteResults
import org.ton.examples.compileAndAnalyzeFift
import org.ton.examples.propertiesFound
import org.ton.examples.runFiftMethod
import org.ton.examples.testFiftOptions
import org.ton.examples.testOptionsToAnalyzeSpecificMethod
import org.usvm.test.resolver.TvmSuccessfulExecution
import org.usvm.test.resolver.TvmTestIntegerValue
import java.math.BigInteger
import kotlin.io.path.Path
import kotlin.test.Test
import kotlin.test.assertEquals

class ContinuationTest {
    private val continuationsFiftPath: String = "/continuations/Continuations.fif"
    private val tryCatchOldCompilerFiftPath: String = "/continuations/complex-try-func-0.4.4.fif"
    private val tryCatchNewCompilerFiftPath: String = "/continuations/complex-try-func-0.4.6.fif"

    @Test
    fun testContinuations() {
        val fiftResourcePath = this::class.java.getResource(continuationsFiftPath)?.path?.let { Path(it) }
            ?: error("Cannot find resource fift $continuationsFiftPath")

        val symbolicResult = compileAndAnalyzeFift(fiftResourcePath, tvmOptions = testFiftOptions)

        val methodIds = (0..3).toSet()
        compareSymbolicAndConcreteResults(methodIds, symbolicResult) { methodId ->
            runFiftMethod(fiftResourcePath, methodId)
        }
    }

    @Test
    fun testTryCatchOldCompiler() {
        // Code generated by FunC compiler before the 0.4.6 version does not work properly, see https://github.com/ton-blockchain/ton/pull/1332
        // Read https://gist.github.com/Damtev/402edd59bef9526e6c670f1781a82ba3 for more details
        Assertions.assertThrows(AssertionError::class.java) {
            testTryCatch(tryCatchOldCompilerFiftPath)
        }
    }

    @Test
    fun testTryCatchNewCompiler() {
        testTryCatch(tryCatchNewCompilerFiftPath)
    }

    private fun testTryCatch(fiftCodePath: String) {
        val fiftResourcePath = this::class.java.getResource(fiftCodePath)?.path?.let { Path(it) }
            ?: error("Cannot find resource fift $fiftCodePath")

        val someThrowingMethodId = BigInteger.valueOf(42)
        // Analyze only `test_try_catch` method - ignore `some_throwing` and `main` methods,
        // and a method that was artificially created with disassembler
        val symbolicResult = compileAndAnalyzeFift(
            fiftResourcePath,
            methodsBlackList = setOf(BigInteger.ZERO, someThrowingMethodId),
            tvmOptions = testOptionsToAnalyzeSpecificMethod
        )

        // We have analyzed just one method, retrieve its executions
        val executions = symbolicResult.testSuites.single()

        // Only three branches are possible:
        assertEquals(3, executions.size)
        // - op == 1 -> nothing is thrown, simple return -> successful try -> [1337] is a resulting stack
        // - op == 2 -> nothing is thrown but alternative return -> successful try -> [1337] is a resulting stack
        // - op != 1 && op != 2 -> 1 is thrown -> going to the catch block -> [42] is a resulting stack
        propertiesFound(
            executions,
            listOf(
                // op == 1 -> nothing is thrown, simple return -> successful try -> [1337] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = ((execution.result as TvmSuccessfulExecution).stack.map { (it as TvmTestIntegerValue).value })

                    op == BigInteger.ONE && stackResultValues.size == 1 && stackResultValues.single() == BigInteger.valueOf(1337)
                },
                // op == 2 -> nothing is thrown but alternative return -> successful try -> [1337] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = ((execution.result as TvmSuccessfulExecution).stack.map { (it as TvmTestIntegerValue).value })

                    op == BigInteger.valueOf(2) && stackResultValues.size == 1 && stackResultValues.single() == BigInteger.valueOf(1337)
                },
                // op != 1 && op != 2 -> 1 is thrown -> going to the catch block -> [42] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = ((execution.result as TvmSuccessfulExecution).stack.map { (it as TvmTestIntegerValue).value })

                    op != BigInteger.ONE && op != BigInteger.valueOf(2) && stackResultValues.size == 1 && stackResultValues.single() == BigInteger.valueOf(42)
                },
            )
        )
    }
}
