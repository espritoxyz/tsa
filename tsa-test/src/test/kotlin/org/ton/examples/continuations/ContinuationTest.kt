package org.ton.examples.continuations

import org.junit.jupiter.api.Assertions
import org.ton.test.utils.compareSymbolicAndConcreteResults
import org.ton.test.utils.compileAndAnalyzeFift
import org.ton.test.utils.extractResource
import org.ton.test.utils.propertiesFound
import org.ton.test.utils.runFiftMethod
import org.ton.test.utils.testConcreteOptions
import org.ton.test.utils.testOptionsToAnalyzeSpecificMethod
import org.usvm.test.resolver.TvmSuccessfulExecution
import org.usvm.test.resolver.TvmTestIntegerValue
import java.math.BigInteger
import kotlin.test.Test
import kotlin.test.assertEquals

class ContinuationTest {
    private val continuationsFiftPath: String = "/continuations/Continuations.fif"
    private val tryCatchOldCompilerFiftPath: String = "/continuations/complex-try-func-0.4.4.fif"
    private val tryCatchNewCompilerFiftPath: String = "/continuations/complex-try-func-0.4.6.fif"

    @Test
    fun testContinuations() {
        val fiftResourcePath = extractResource(continuationsFiftPath)

        val symbolicResult = compileAndAnalyzeFift(fiftResourcePath, tvmOptions = testConcreteOptions)

        val methodIds = (0..3).toSet()
        compareSymbolicAndConcreteResults(methodIds, symbolicResult) { methodId ->
            runFiftMethod(fiftResourcePath, methodId)
        }
    }

    @Test
    fun testTryCatchOldCompiler() {
        // Code generated by FunC compiler before the 0.4.6 version does not work properly, see https://github.com/ton-blockchain/ton/pull/1332
        // Read https://gist.github.com/Damtev/402edd59bef9526e6c670f1781a82ba3 for more details
        Assertions.assertThrows(AssertionError::class.java) {
            testTryCatch(tryCatchOldCompilerFiftPath)
        }
    }

    @Test
    fun testTryCatchNewCompiler() {
        testTryCatch(tryCatchNewCompilerFiftPath)
    }

    private fun testTryCatch(fiftCodePath: String) {
        val fiftResourcePath = extractResource(fiftCodePath)

        val someThrowingMethodId = BigInteger.valueOf(42)
        // Analyze only `test_try_catch` method - ignore `some_throwing` and `main` methods,
        // and a method that was artificially created with disassembler
        val symbolicResult =
            compileAndAnalyzeFift(
                fiftResourcePath,
                methodsBlackList = setOf(BigInteger.ZERO, someThrowingMethodId),
                tvmOptions = testOptionsToAnalyzeSpecificMethod
            )

        // We have analyzed just one method, retrieve its executions
        val executions = symbolicResult.testSuites.single()

        // Only three branches are possible:
        assertEquals(3, executions.size)
        // - op == 1 -> nothing is thrown, simple return -> successful try -> [1337] is a resulting stack
        // - op == 2 -> nothing is thrown but alternative return -> successful try -> [1337] is a resulting stack
        // - op != 1 && op != 2 -> 1 is thrown -> going to the catch block -> [42] is a resulting stack
        propertiesFound(
            executions,
            listOf(
                // op == 1 -> nothing is thrown, simple return -> successful try -> [1337] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = (
                        (execution.result as TvmSuccessfulExecution).stack.map {
                            (it as TvmTestIntegerValue)
                                .value
                        }
                    )

                    op == BigInteger.ONE &&
                        stackResultValues.size == 1 &&
                        stackResultValues.single() == BigInteger.valueOf(1337)
                },
                // op == 2 -> nothing is thrown but alternative return -> successful try -> [1337] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = (
                        (execution.result as TvmSuccessfulExecution).stack.map {
                            (it as TvmTestIntegerValue)
                                .value
                        }
                    )

                    op == BigInteger.valueOf(2) &&
                        stackResultValues.size == 1 &&
                        stackResultValues.single() == BigInteger.valueOf(1337)
                },
                // op != 1 && op != 2 -> 1 is thrown -> going to the catch block -> [42] is a resulting stack
                { execution ->
                    val op = (execution.input.usedParameters.single() as TvmTestIntegerValue).value
                    val stackResultValues = (
                        (execution.result as TvmSuccessfulExecution).stack.map {
                            (it as TvmTestIntegerValue)
                                .value
                        }
                    )

                    op != BigInteger.ONE &&
                        op != BigInteger.valueOf(2) &&
                        stackResultValues.size == 1 &&
                        stackResultValues.single() == BigInteger.valueOf(42)
                }
            )
        )
    }
}
